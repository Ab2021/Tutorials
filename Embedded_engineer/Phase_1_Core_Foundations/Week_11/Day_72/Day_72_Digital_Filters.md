# Day 72: Digital Filters (FIR/IIR) Implementation
## Phase 1: Core Embedded Engineering Foundations | Week 11: DSP & Audio Processing

---

> **ğŸ“ Content Creator Instructions:**
> This document is designed to produce **comprehensive, industry-grade educational content**. 
> - **Target Length:** The final filled document should be approximately **1000+ lines** of detailed markdown.
> - **Depth:** Do not skim over details. Explain *why*, not just *how*.
> - **Structure:** If a topic is complex, **DIVIDE IT INTO MULTIPLE PARTS** (Part 1, Part 2, etc.).
> - **Code:** Provide complete, compilable code examples, not just snippets.
> - **Visuals:** Use Mermaid diagrams for flows, architectures, and state machines.

---

## ğŸ¯ Learning Objectives
*By the end of this day, the learner will be able to:*
1.  **Compare** FIR (Finite Impulse Response) and IIR (Infinite Impulse Response) filters in terms of stability, phase, and computational cost.
2.  **Design** filter coefficients (Low Pass, High Pass) using external tools (MATLAB/Python/Web).
3.  **Implement** an FIR filter using `arm_fir_f32`.
4.  **Implement** an IIR filter (Biquad) using `arm_biquad_cascade_df1_f32`.
5.  **Visualize** the filtering effect on a noisy signal.

---

## ğŸ“š Prerequisites & Preparation
*   **Hardware Required:**
    *   STM32F4 Discovery Board
*   **Software Required:**
    *   VS Code with ARM GCC Toolchain
    *   [TFilter (Web Tool)](http://t-filter.engineerjs.com/) or Python `scipy.signal`.
*   **Prior Knowledge:**
    *   Day 71 (CMSIS-DSP)
    *   Day 24 (Moving Average - Simple FIR)
*   **Datasheets:**
    *   [CMSIS-DSP Filtering Functions](https://arm-software.github.io/CMSIS_5/DSP/html/group__groupFilters.html)

---

## ğŸ“– Theoretical Deep Dive

### ğŸ”¹ Part 1: FIR vs IIR
*   **FIR (Finite Impulse Response):**
    *   $y[n] = b_0 x[n] + b_1 x[n-1] + ... + b_N x[n-N]$
    *   **Pros:** Always stable. Linear Phase (no distortion).
    *   **Cons:** Needs many taps (coefficients) for sharp cutoff. High CPU usage.
*   **IIR (Infinite Impulse Response):**
    *   $y[n] = b_0 x[n] + ... - a_1 y[n-1] - ...$
    *   **Pros:** Very sharp cutoff with few coefficients (low CPU).
    *   **Cons:** Can be unstable (feedback). Non-linear phase.

### ğŸ”¹ Part 2: Filter Design
We don't guess coefficients. We calculate them.
*   **Goal:** Low Pass Filter. Cutoff 100 Hz. Sample Rate 1000 Hz.
*   **Tool:** Generates `float32_t coeffs[]`.

---

## ğŸ’» Implementation: FIR Low Pass Filter

> **Instruction:** Filter out high frequency noise from a 50Hz sine wave.

### ğŸ‘¨â€ğŸ’» Code Implementation

#### Step 1: Generate Noisy Signal
```c
#define BLOCK_SIZE 32
#define NUM_TAPS 29 // Generated by tool

float32_t inputSignal[BLOCK_SIZE];
float32_t outputSignal[BLOCK_SIZE];
float32_t firState[BLOCK_SIZE + NUM_TAPS - 1]; // State buffer

// Coefficients for 100Hz LPF @ 1kHz Fs (Example values)
const float32_t firCoeffs[NUM_TAPS] = {
    -0.001, 0.002, 0.005, ... // 29 values
};

void Generate_Noisy_Signal(void) {
    static float32_t t = 0;
    for(int i=0; i<BLOCK_SIZE; i++) {
        // 50Hz Signal + 400Hz Noise
        inputSignal[i] = arm_sin_f32(2*PI*50*t) + 0.5f * arm_sin_f32(2*PI*400*t);
        t += 0.001f; // 1kHz Sample Rate
    }
}
```

#### Step 2: Init & Run
```c
arm_fir_instance_f32 S;

void Filter_Init(void) {
    arm_fir_init_f32(&S, NUM_TAPS, (float32_t*)firCoeffs, firState, BLOCK_SIZE);
}

void Filter_Process(void) {
    Generate_Noisy_Signal();
    
    // Process Block
    arm_fir_f32(&S, inputSignal, outputSignal, BLOCK_SIZE);
    
    // Print first few samples
    printf("In: %f, Out: %f\n", inputSignal[0], outputSignal[0]);
}
```

---

## ğŸ’» Implementation: IIR Biquad Filter

> **Instruction:** Use a Biquad (2nd Order Section) for efficient filtering.

### ğŸ‘¨â€ğŸ’» Code Implementation

#### Step 1: Coefficients
IIR coeffs are usually 5 per stage: $b_0, b_1, b_2, a_1, a_2$.
```c
#define NUM_STAGES 1 // 1 Biquad
float32_t iirState[4 * NUM_STAGES];
const float32_t iirCoeffs[5 * NUM_STAGES] = {
    0.1, 0.2, 0.1, 1.5, -0.7 // Example
};

arm_biquad_casd_df1_inst_f32 S_IIR;
```

#### Step 2: Init & Run
```c
void IIR_Init(void) {
    arm_biquad_cascade_df1_init_f32(&S_IIR, NUM_STAGES, (float32_t*)iirCoeffs, iirState);
}

void IIR_Process(void) {
    arm_biquad_cascade_df1_f32(&S_IIR, inputSignal, outputSignal, BLOCK_SIZE);
}
```

---

## ğŸ”¬ Lab Exercise: Lab 72.1 - The Noise Cleaner

### 1. Lab Objectives
- Visualize the noise removal.
- Use STM32CubeMonitor or Serial Plotter.

### 2. Step-by-Step Guide

#### Phase A: Setup
1.  Main loop calls `Filter_Process` every 32ms (real-time simulation).
2.  Print `In, Out` to UART in CSV format: `0.5, 0.1\n`.

#### Phase B: Plot
1.  Open Arduino Serial Plotter (or similar).
2.  **Observation:** Blue line (Input) is jagged. Orange line (Output) is smooth sine wave.

### 3. Verification
If output is flatline (0), check coefficients. If output explodes (Infinity), filter is unstable (IIR poles outside unit circle).

---

## ğŸ§ª Additional / Advanced Labs

### Lab 2: High Pass Filter
- **Goal:** Remove DC Offset.
- **Task:**
    1.  Add DC bias: `signal = sin() + 2.0f`.
    2.  Design HPF (Cutoff 5Hz).
    3.  Apply Filter.
    4.  **Result:** Output centers around 0.

### Lab 3: Band Stop (Notch) Filter
- **Goal:** Remove 50Hz/60Hz Mains Hum.
- **Task:**
    1.  Design Notch Filter at 50Hz.
    2.  Input: 10Hz Signal + 50Hz Hum.
    3.  Output: Clean 10Hz Signal.

---

## ğŸ Debugging & Troubleshooting

### Common Issues

#### 1. State Buffer Corruption
*   **Cause:** `firState` array too small.
*   **Rule:** Size must be `BLOCK_SIZE + NUM_TAPS - 1`.

#### 2. Coefficient Order
*   **Cause:** MATLAB gives `a` coeffs as `a0, a1, a2`. CMSIS expects `a1, a2` (and inverted sign sometimes).
*   **Solution:** Check CMSIS documentation carefully. For IIR, it expects: `b0, b1, b2, a1, a2`.

---

## âš¡ Optimization & Best Practices

### Code Quality
- **Q15 Optimization:** If F32 is too slow, switch to Q15. `arm_fir_q15` uses SIMD and is 4x faster. But be careful of overflow (saturation).

---

## ğŸ§  Assessment & Review

### Knowledge Check
1.  **Q:** Why does FIR have "Linear Phase"?
    *   **A:** Because the delay is constant for all frequencies. This preserves the shape of the waveform (important for Audio/ECG). IIR distorts the shape.
2.  **Q:** What is a "Tap"?
    *   **A:** A coefficient/delay pair. A 29-tap filter looks at the current sample and 28 previous samples.

### Challenge Task
> **Task:** Implement a "Matched Filter". Create a specific pattern (e.g., a "Chirp"). Use FIR with coefficients equal to the reversed pattern. When the pattern appears in the input, the output spikes (Correlation). Used in Radar/Sonar.

---

## ğŸ“š Further Reading & References
- [Introduction to Digital Filters](https://www.dspguide.com/ch14.htm)

---
